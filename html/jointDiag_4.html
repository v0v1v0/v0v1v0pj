<div class="container">

<table style="width: 100%;"><tr>
<td>jedi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximate non-orthogonal joint diagonalization of a set of square
real-valued matrices</h2>

<h3>Description</h3>

<p>This function performs a Joint Approximate Diagonalization of a set of
square and real-valued matrices (not necessarily symmetric). 
The algorithm seeks the inverse of the joint
diagonalizer (the mixing matrix in terms of source separation).
</p>
<p>The algorithm uses Givens and hyperbolic rotations to find the inverse of 
a non-orthogonal joint diagonalizer. It is an extension of the
JADE method (orthogonal joint diagonalization). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">jedi(M, A0 = NULL, eps = .Machine$double.eps, itermax = 200, 
		keepTrace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>DOUBLE ARRAY (KxKxN). Three-dimensional array with dimensions 
KxKxN representing the set
of square and real-valued matrices to be jointly diagonalized. 
N is the number of matrices. Matrices
are KxK square matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of the inverse of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>DOUBLE. The algorithm stops when the criterium difference 
between two
iterations is less than eps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax</code></td>
<td>
<p>INTEGER. Alternatively, the algorithm stops when itermax 
sweeps have
been performed without reaching convergence. If the maximum number of
iteration is performed, a warning appears.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepTrace</code></td>
<td>
<p>BOOLEAN. Do we want to keep the successive estimations of 
the joint diagonalizer.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a set <code class="reqn">M_i</code> of <code>N</code> <code>K</code> <code class="reqn">\times</code> <code>K</code> square and
real-valued matrices, the
algorithm is looking for a matrix <code class="reqn">A</code> such that
<code class="reqn">\forall i \in [1,N]</code>, <code class="reqn">A^{-1} C_i A^{-T}</code> is as close as possible of a
diagonal matrix. 
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Estimation of the Joint Diagonalizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criter</code></td>
<td>
<p>Successive estimates of the cost function across sweeps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A_trace</code></td>
<td>
<p>Array of the successive estimates of A across iterations.</p>
</td>
</tr>
</table>
<h3>Warning </h3>

<p>This algorithm based on a combination of givens and hyperbolic rotations is
covered by a patent (see A. Souloumiac, CEA Saclay).
</p>


<h3>Author(s)</h3>

<p>Cedric Gouy-Pailler (cedric.gouypailler@gmail.com),
with help from Antoine Souloumiac.</p>


<h3>References</h3>

<p>Souloumiac, A.; Non-Orthogonal Joint Diagonalization by Combining
Givens and Hyperbolic Rotations; IEEE Trans. Signal Process., 2009</p>


<h3>Examples</h3>

<pre><code class="language-R"># generating diagonal matrices
D &lt;- replicate(30, diag(rchisq(df=1,n=10)), simplify=FALSE)
# Mixing and demixing matrices
B &lt;- matrix(rnorm(100),10,10)
A &lt;- solve(B)
C &lt;- array(NA,dim=c(10,10,30))
for (i in 1:30) C[,,i] &lt;- A %*% D[[i]] %*% t(A)
A_est &lt;- jedi(C)$A
# A_est should be an approximate of A
B %*% A_est
# close to a permutation matrix (with random scales)
</code></pre>


</div>