<div class="container">

<table style="width: 100%;"><tr>
<td>ajd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Wrapper: Joint approximate diagonalization of a set of matrices</h2>

<h3>Description</h3>

<p>This function is mainly a wrapper to the different algorithms provided in the
package. So see the help of the different algorithms for the details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ajd(M, A0 = NULL, B0 = NULL, eps = .Machine$double.eps, 
	itermax = 200, keepTrace = FALSE, methods = c("jedi"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>DOUBLE ARRAY (KxKxN). Three-dimensional array with dimensions 
KxKxN representing the set
of square and real-valued matrices to be jointly diagonalized. 
N is the number of matrices. Matrices
are KxK square matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of the inverse of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>DOUBLE. The algorithm stops when the criterion difference 
between two
iterations is less than eps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax</code></td>
<td>
<p>INTEGER. Alternatively, the algorithm stops when itermax 
sweeps have
been performed without reaching convergence. If the maximum number of
iteration is performed, a warning appears.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepTrace</code></td>
<td>
<p>BOOLEAN. Do we want to keep the successive estimations of 
the joint diagonalizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methods</code></td>
<td>
<p>STRING. One or more methods, choosen among the set of available
algorithms. Possible values are: jedi, ffdiag, jadiag, uwedge, qdiag</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is mainly a wrapper to use the different algorithms provided
in the package (see help of the different functions).
</p>


<h3>Value</h3>

<p>If the number of methods is one, the result is the structure provided by
the algorithm used.
</p>
<p>If the number of methods is more than one, a list of results provided by
each algorithm is given. Names of the list correspond to methods.
</p>


<h3>Author(s)</h3>

<p>Cedric Gouy-Pailler (cedric.gouypailler@gmail.com)</p>


<h3>Examples</h3>

<pre><code class="language-R"># generating diagonal matrices
D &lt;- replicate(30, diag(rchisq(df=1,n=10)), simplify=FALSE)
# Mixing and demixing matrices
B &lt;- matrix(rnorm(100),10,10)
A &lt;- solve(B)
C &lt;- array(NA,dim=c(10,10,30))
for (i in 1:30) C[,,i] &lt;- A %*% D[[i]] %*% t(A)
ajd(C,method=c("jedi","ffdiag"))
</code></pre>


</div>