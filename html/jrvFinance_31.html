<div class="container">

<table style="width: 100%;"><tr>
<td>irr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal Rate of Return</h2>

<h3>Description</h3>

<p>Computes IRR (Internal Rate of Return) for cash flows with different cash flow and
compounding conventions. Cash flows need not be evenly spaced.
</p>


<h3>Usage</h3>

<pre><code class="language-R">irr(
  cf,
  interval = NULL,
  cf.freq = 1,
  comp.freq = 1,
  cf.t = seq(from = 0, by = 1/cf.freq, along.with = cf),
  r.guess = NULL,
  toler = 1e-06,
  convergence = 1e-08,
  max.iter = 100,
  method = c("default", "newton", "bisection")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cf</code></td>
<td>
<p>Vector of cash flows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>the interval c(lower, upper) within which to
search for the IRR</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cf.freq</code></td>
<td>
<p>Frequency of annuity payments: 1 for annual, 2 for
semi-annual, 12 for monthly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp.freq</code></td>
<td>
<p>Frequency of compounding of interest rates: 1 for annual,
2 for semi-annual, 12 for monthly, Inf for continuous compounding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cf.t</code></td>
<td>
<p>Optional vector of timing (in years) of cash flows. If omitted
regular sequence of years is assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r.guess</code></td>
<td>
<p>the starting value (guess) from which the solver
starts searching for the IRR</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toler</code></td>
<td>
<p>the argument <code>toler</code> for
<code>irr.solve</code>.  The IRR is regarded as correct if
abs(NPV) is less than <code>toler</code>.  Otherwise the <code>irr</code>
function returns <code>NA</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>the argument <code>convergence</code> for
<code>irr.solve</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>the argument <code>max.iter</code> for
<code>irr.solve</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The root finding method to be used. The
<code>default</code> is to try Newton-Raphson method
(<code>newton.raphson.root</code>) and if that fails to try
bisection (<code>bisection.root</code>). The other two
choices (<code>newton</code> and <code>bisection</code> force only one of
the methods to be tried.</p>
</td>
</tr>
</table>
</div>