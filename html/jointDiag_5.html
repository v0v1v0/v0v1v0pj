<div class="container">

<table style="width: 100%;"><tr>
<td>qdiag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Joint Approximate Diagonalization of a set of square, symmetric
and real-valued matrices</h2>

<h3>Description</h3>

<p>This function performs a Joint Approximate Diagonalization of a set of
square, symmetric and real-valued matrices. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">qdiag(C, W0 = NULL, eps = .Machine$double.eps, itermax = 200, 
		keepTrace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>DOUBLE ARRAY (KxKxN). Three-dimensional array with dimensions 
KxKxN representing the set
of square, symmetric and real-valued matrices to be jointly diagonalized. 
N is the number of matrices. Matrices
are KxK square matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>DOUBLE. The algorithm stops when the criterium difference 
between two
iterations is less than eps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax</code></td>
<td>
<p>INTEGER. Alternatively, the algorithm stops when itermax 
sweeps have
been performed without reaching convergence. If the maximum number of
iteration is performed, a warning appears.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepTrace</code></td>
<td>
<p>BOOLEAN. Do we want to keep the successive estimations of 
the joint diagonalizer.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a set <code class="reqn">C_i</code> of N KxK symmetric and real-valued matrices, the
algorithm is looking for a matrix <code class="reqn">B</code> such that
<code class="reqn">\forall i \in [1,N]</code>, <code class="reqn">B C_i B^T</code> is as close as possible of a
diagonal matrix. 
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Estimation of the Joint Diagonalizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criter</code></td>
<td>
<p>Successive estimates of the cost function across sweeps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B_trace</code></td>
<td>
<p>Array of the successive estimates of B across iterations.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Two versions of the quadratic optimization are present in the paper
referenced below. These two
versions have different complexities, <code>O(N K^3)</code> and <code>O(K^5)</code>.
Currently only the version with <code>O(N K^3)</code> is implemented.
</p>


<h3>Author(s)</h3>

<p>Cedric Gouy-Pailler (cedric.gouypailler@gmail.com), 
from the initial matlab code by R. Vollgraf.</p>


<h3>References</h3>

<p>R. Vollgraf and K. Obermayer; Quadratic Optimization for
Approximate Matrix Diagonalization; IEEE Transaction on Signal Processing, 
2006</p>


<h3>Examples</h3>

<pre><code class="language-R"># generating diagonal matrices
D &lt;- replicate(30, diag(rchisq(df=1,n=10)), simplify=FALSE)
# Mixing and demixing matrices
B &lt;- matrix(rnorm(100),10,10)
A &lt;- solve(B)
C &lt;- array(NA,dim=c(10,10,30))
for (i in 1:30) C[,,i] &lt;- A %*% D[[i]] %*% t(A)
B_est &lt;- qdiag(C)$B
# B_est should be an approximate of B=solve(A)
B_est %*% A
# close to a permutation matrix (with random scales)
</code></pre>


</div>