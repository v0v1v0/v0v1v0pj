<div class="container">

<table style="width: 100%;"><tr>
<td>jadiag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Joint Approximate Diagonalization of a set of square, symmetric
and real-valued matrices</h2>

<h3>Description</h3>

<p>This function performs a Joint Approximate Diagonalization of a set of
square, symmetric and real-valued matrices. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">jadiag(M, W_est0 = NULL, eps = .Machine$double.eps, itermax = 200, 
		keepTrace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>DOUBLE ARRAY (KxKxN). Three-dimensional array with dimensions 
KxKxN representing the set
of square, symmetric and real-valued matrices to be jointly diagonalized. 
N is the number of matrices. Matrices
are KxK square matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W_est0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>DOUBLE. The algorithm stops when the criterium difference 
between two
iterations is less than eps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax</code></td>
<td>
<p>INTEGER. Alternatively, the algorithm stops when itermax 
sweeps have
been performed without reaching convergence. If the maximumu number of
iteration is performed, a warning appears.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepTrace</code></td>
<td>
<p>BOOLEAN. Do we want to keep the successive estimations of 
the joint diagonalizer.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a set <code class="reqn">C_i</code> of N KxK symmetric and real-valued matrices, the
algorithm is looking for a matrix <code class="reqn">B</code> such that
<code class="reqn">\forall i \in [1,N]</code>, <code class="reqn">B C_i B^T</code> is as close as possible of a
diagonal matrix. 
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Estimation of the Joint Diagonalizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criter</code></td>
<td>
<p>Successive estimates of the cost function across sweeps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B_trace</code></td>
<td>
<p>Array of the successive estimates of B across iterations.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Cedric Gouy-Pailler (cedric.gouypailler@gmail.com), 
from the initial C code by Dinh-Tuan Pham.</p>


<h3>References</h3>

<p>Pham, D. &amp; Cardoso, J.; Blind separation of instantaneous mixtures
of nonstationary sources; IEEE Trans. Signal Process., 2001, 49, 1837-1848</p>


<h3>Examples</h3>

<pre><code class="language-R"># generating diagonal matrices
D &lt;- replicate(30, diag(rchisq(df=1,n=10)), simplify=FALSE)
# Mixing and demixing matrices
B &lt;- matrix(rnorm(100),10,10)
A &lt;- solve(B)
C &lt;- array(NA,dim=c(10,10,30))
for (i in 1:30) C[,,i] &lt;- A %*% D[[i]] %*% t(A)
B_est &lt;- jadiag(C)$B
# B_est should be an approximate of B=solve(A)
B_est %*% A
# close to a permutation matrix (with random scales)
</code></pre>


</div>